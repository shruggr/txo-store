import type { Transaction } from '@bsv/sdk';
import { TxnStatus, type Txn } from './models/txn';
import { Level } from 'level';
import { Txo } from './models/txo';
import type { IndexContext } from './models/index-context';
import type { Block } from './models/block';
import { IndexData } from './models/index-data';
import { indexAddress } from './indexers/address';
import type { AbstractSublevel } from 'abstract-level'
import { Outpoint } from './models/outpoint';

export interface TxoStoreOptions {
    arcUrl?: string
    arcApiKey?: string
    txFetcher?: (txid: string) => Promise<ArrayBuffer>
    indexers: { [key: string]: (idxCtx: IndexContext, vout: number) => IndexData }
}

export class TxoStore {
    private db = new Level<string, any>('txostore')
    private txns = this.db.sublevel<string, Txn>('txns', { valueEncoding: 'json' })
    private blocksByHeight = this.db.sublevel<number, Block>('blocksByHeight', { valueEncoding: 'json' })
    private txos = this.db.sublevel<string, Txo>('txos', { valueEncoding: 'json' })
    private account: AbstractSublevel<Level<string, any>, any, string, string>
    private rawtx = this.db.sublevel<string, Uint8Array>('rawtx', { valueEncoding: 'view' })
    private addresses: AbstractSublevel<AbstractSublevel<Level<string, any>, any, string, string>, any, string, number>
    private opt: TxoStoreOptions = {
        indexers: {
            address: indexAddress
        }
    }

    constructor(public accountId: string, opt?: TxoStoreOptions) {
        this.account = this.db.sublevel<string, string>(accountId, {})
        this.addresses = this.account.sublevel<string, number>('addresses', {})

        if (opt) this.opt = {
            ...this.opt,
            ...opt
        }
    }

    async getTx(txid: string): Promise<Txn | undefined> {
        return await this.txns.get(txid).catch(() => undefined)
    }

    async getRawtx(txid: string): Promise<Uint8Array | undefined> {
        return this.rawtx.get(txid).catch(() => undefined)
    }

    async getTxo(outpoint: string): Promise<Txo | undefined> {
        return this.txos.get(outpoint).catch(() => undefined)
    }

    async trackAddress(address: string) {
        this.addresses.put(address, Date.now())
    }

    async ingest(tx: Transaction): Promise<IndexContext | undefined> {
        const txid = tx.hash('hex') as string

        if (await this.txns.get(txid)) return
        let block: Block | undefined
        if (tx.merklePath) {
            block = {
                height: tx.merklePath.blockHeight,
                idx: BigInt(tx.merklePath.path[0].find((x) => x.hash == txid)!.offset),
                // TODO: lookup hash from block headers
                hash: (await this.blocksByHeight.get(tx.merklePath.blockHeight))?.hash || ''
            }
        }
        const idxCtx: IndexContext = {
            txid,
            block,
            rawtx:new Uint8Array(tx.toBinary()),
            txos: [],
            spends: [],
        }

        for await (let [, txin] of tx.inputs.entries()) {
            if (txin.sourceTransaction) {
                await this.ingest(txin.sourceTransaction)
                if (!txin.sourceTXID) txin.sourceTXID = txin.sourceTransaction.hash('hex') as string
            }
        }

        const txn = {
            txid,
            block,
            status: TxnStatus.PENDING,
            score: block?.height || Date.now(),
        }
        this.txns.put(txid, txn)
        let batch = this.db.batch()
        for (let [vin, txin] of tx.inputs.entries()) {
            const outpoint = `${txin.sourceTXID}_${txin.sourceOutputIndex}`
            const spendTxo = await this.getTxo(outpoint)
            if (!spendTxo) {
                continue
                // throw new Error(`not-found: ${outpoint}`)
            }
            spendTxo.spend = {
                txid,
                vin,
                block,
            }
            idxCtx.spends.push(spendTxo)
            batch.put(this.txos.prefixKey(spendTxo.outpoint.toString(), 'utf8'), spendTxo)
        }

        for await (let [vout, output] of tx.outputs.entries()) {
            let txo: Txo = await this.txos.get(`${txid}_${vout}`)
            if (!txo) {
                txo = new Txo(
                    new Outpoint(`${txid}_${vout}`), 
                    new Uint8Array(output.lockingScript.toBinary()), 
                    BigInt(output.satoshis!)
                )
            }
            txo.block = block
            for (let [tag, indexer] of Object.entries(this.opt.indexers)) {
                const idxData = await indexer(idxCtx, vout)
                txo.data[tag] = idxData
            }
            idxCtx.txos.push(txo)
            batch.put(this.txos.prefixKey(txo.outpoint.toString(), 'utf8'), txo)
            const spent = txo.spend ? 1 : 0
            const score = (txo.spend ?
                txo.spend.block?.height || Date.now() :
                txo.block?.height || Date.now()
            ).toString(16).padStart(8, '0')
            Object.entries(txo.data).forEach(([tag, idxData]) => {
                idxData.ids.forEach((id) => {
                    batch.put(`${id}:${spent}:${score}`, txo)
                })
                idxData.events.forEach((event) => {
                    batch.put(`${tag}:${event.id}:${event.value}:${spent}:${score}`, txo)
                })
            })
        }

        await batch.write()
        this.txns.put(txid, {
            txid,
            block,
            status: block ? TxnStatus.PENDING : TxnStatus.CONFIRMED,
            score: block?.height || Date.now(),
        })

        return idxCtx
    }
}

